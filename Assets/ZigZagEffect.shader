Shader "Unlit/ZigZag Marker Effect"
{
    // **** Input data sent in from unity ****
    // Sometimes known as constants, because they are constant over a give
    // invocation of the shader. It forms one of the key inputs into the shader,
    // the other being the HLSL constants that we map to our fragment shader inputs
    // further on in this shader (below).
    // Format: 
    // <Name in code> (<Name in unity UI>, <Data type>)  = <Default value>
    Properties
    {
        _ColorA("Color A", Color) = (1,1,1,1)
        _ColorB("Color B", Color) = (1,1,1,1)
    }
    // Render pipeline related. e.g. queueing priority of the shader
    SubShader
    {
        // Subshader tags
        Tags 
        { 
            // ***  Render type ****
            // The type tag assigned to this shader, used mainly in post process effects
            "RenderType"="Transparent" 
            // **** Queue tag ****
            // Use this tag to change the render order.
            // this determines in which queue the shader will be written
            // which in turn determines what order the shader will be run in 
            // relative to other shader types:
            //  - Background
            //  - Geometry (Opaque)	   
            //  - AlphaTest	   
            //  - Transparent
            //  - Overlay	   
            // https://docs.unity3d.com/Manual/SL-SubShaderTags.html
            "Queue" = "Transparent" 
        }

        // What level of detail this shader should be applied to
        LOD 100

        // this render pass itself (e.g. blending mode, stencil properties)
        Pass
        {
            // pass tags
            
            // **** Triangle culling ****
            // Show both sides of the triangles 
            Cull Off
            
            // **** Testing against the depth buffer ****
            // only pass a comparison to depth buffer value, if the 
            // current depth is greater than the buffer depth value 
            // (i.e. we are we are behind it).
            // ZTest GEqual // (greater than or equal)
            //
            // always pass a comparison to value in the depth buffer
            // ZTest Always
            // 
            // only pass a comparison to depth buffer value, if the 
            // current depth is less than the buffer depth value 
            // (i.e. we are we are infront of it). Default value.
            ZTest LEqual  // (less than or equal)
            
            // **** Writing to the depth buffer ****
            // The shader will not write to the z-buffer, (so other 
            // fragments can write over this one).
            // When used in conjunction blend 
            ZWrite Off 
            
            // **** Blending **** 
            // Should be interpreted with the following (fixed) formula
            // src.A (+/-) dst.B
            // where:
            // - src is the color generated by the fragment shader
            // - dst is the color currently behind the in the color buffer?
            // - A/B are configurable color values and are the ones set below
            // Default is "Blend Off"
            // https://docs.unity3d.com/Manual/SL-Blend.html
            Blend One One // src.1 + dst.1 - additive
            //Blend DstColor Zero // multiply
            
            // Anything from CGPROGRAM > ENDCG is HLSL code 
            // forming the shader program that runs on the GPU
            // outside of this is the Unity's shaderlab code
            CGPROGRAM   
            // aliases for the shader functions
            #pragma vertex vert 
            #pragma fragment frag

            // Some Syntax information in HLSL
            // Integer values:
            //  - bool 0 1
            //  - int (can have vectors of ints) 
            // Floating point values:
            //  - float (32 bit float) 
            //  - half (16 bit float)
            //  - fixed (12 bit float) generally used for -1 to 1
            // Vectors:
            //  - float4 > half4 > fixed4
            // Mat:
            //  - float4x4 > half4x4 
            
            // pastes in some reusable shader functions
            #include "UnityCG.cginc"
            #include "ShaderFuncs.cginc"

            // These properties are defined in the Properties section
            // in the unity shaderlab code above
            float4 _ColorA;
            float4 _ColorB;

            // ***Input to the Vertex shader***:
            // Per vertex mesh data passed in by unity (i.e. APPLICATION)
            // These vary over a given invocation of the shader (draw call).
            // Can be thought of as a for loop going over all the vertices
            // in the original mesh.
            // format: 
            // type - name - attribute name (names used by HLSL https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-semantics)
            // NOTE: input does not have to contain specific points relating to vertices, can generate them. (one at at time)
            // original indices will still be used to form primitves 
            struct MeshData
            {
                float4 vertex : POSITION; // vertex position in local space
                float3 normals: NORMAL; // direction of the normal at this point in local space
                float4 tangent: TANGENT; // tangent direction (xyz) and sign (w)
                float4 color : COLOR; // rgba
                float2 uv0 : TEXCOORD0; // uv0 e.g diffuse/normal map textures
                float2 uv1 : TEXCOORD1; // uv1 e.g. light map texture
            };

            // ****Input to the Fragment shader*** 
            // v2f default name for data that goes from vertex > fragment shader
            // It contains data interpolated between the vertices of the triangle
            struct FragmentData
            {
                // clip space position of vertex
                float4 vertex : SV_POSITION; 
                // TEXCOORD<number> is just the name of the data channels going v2f,
                // its not related to the uv texture coordinates 
                float3 normal : TEXCOORD0;
                float2 uv : TEXCOORD1; 
            };

            // Vertex shader
            FragmentData vert (MeshData meshData)
            {
                FragmentData fragData;
                // use unity function to convert local space to clip space
                fragData.vertex = UnityObjectToClipPos(meshData.vertex);

                // Alternative ways of doing the same thing:
                // output.normal = mul((float3x3)unity_ObjectToWorld, meshData.normals); 
                // You could also do mul(meshData.normals, (float3x3)unity_WorldToObject)
                // and the order of the matrix will determine whether you want to take the inverse
                // UNITY_MATRIX_M == unity_ObjectToWorld
                // Better to stick with unity macros, as there can be difficulties when
                // targeting different systems
                // You could also do this in the fragment shader, but
                // a common way to optimise is to think which shader will b
                // run more for a given object using this overall shader 
                fragData.normal = UnityObjectToWorldNormal(meshData.normals); 


                // Visualize the UV coordinates on the mesh with color
                // remembering that:
                // x = red
                // y = green
                // z = blue
                // output.uv = (meshData.uv0 + _Offset) *  _Scale;

                fragData.uv = meshData.uv0; // pass through

                return fragData;
            }



            // Just need to output a color here.
            // Fragment shader
            float4 frag (FragmentData fragmentData) : SV_Target // single render target
            {
                const int n = 6;
                float yOffset = NZigZag(fragmentData.uv.x * n)* 1/n; 
                float t = NZigZag((fragmentData.uv.y + yOffset - _Time.y*0.3) * n);
                t *= 1-fragmentData.uv.y; // give a fade out effect going up
               
                bool topBottomRemover = abs(fragmentData.normal.y) < 0.999;
                float waves = t * topBottomRemover;
                float4 gradient = lerp(_ColorA, _ColorB, fragmentData.uv.y);
                return gradient * waves;

                // can be used to discard the current pixel leaving the color buffer intact
                //discard
            }
            ENDCG
        }
    }
}
